# Internationalization (i18n) – Phase 1 Overview

This document summarizes the database i18n infrastructure added in Milestone 2 – Phase 1.

- Translation JSONB columns added to master data tables with GIN indexes
- Non-breaking: original `name`, `description`, and `content` columns are retained
- Existing English data migrated into JSONB under `en`
- Profiles table includes `preferred_language` with validation and index
- Helper utilities provided for reading/writing translations in code

## Affected Tables and Columns

- categories: `name_translations`, `description_translations`
- sampradayas: `name_translations`, `description_translations`
- languages: `name_translations`
- service_radius_options: `name_translations`, `description_translations`
- experience_levels: `name_translations`, `description_translations`
- terms: `content_translations`
- profiles: `preferred_language`

Indexes created for every new JSONB column (GIN) and for `profiles.preferred_language`.

## Helper Functions

Location: `apps/web/lib/translations/db-helpers.ts`

- `getTranslation(translations, locale, fallback='en')`
- `buildTranslation(englishText, translations?)`
- `updateTranslation(existing, locale, text)`
- `hasTranslation(translations, locale)`
- `getTranslationCoverage(items, locale, fields)`

Types are available at `apps/web/lib/translations/types.ts`.

## Rollback

A rollback script is available at `infra/supabase/21_i18n_rollback.sql` to drop the added columns and indexes and remove `preferred_language` if necessary.

## Testing

Unit tests for helper functions are under `apps/web/__tests__/translations/db-helpers.spec.ts` (Vitest).

## Next Steps (Phase 2)

- Integrate `next-intl`, add `/messages` structure, middleware, hooks, and a Language Selector component.
- Extract UI strings into `messages/en.json` (no Kannada content yet).

## Milestone 2 — Task Checklist

### Phase 1 — Database i18n Infrastructure (Tasks 1.1–1.7)

1.1 Add JSONB translation columns + GIN indexes to master data tables — DONE

1.2 Backfill existing English content under `en` — DONE

1.3 Rollback script for all changes — DONE

1.4 Helpers and types for translations — DONE

1.5 Update queries/services to include translated fields — DONE

1.6 Apply migration on all dev environments and validate — DONE

1.7 Documentation examples in services and usage patterns — DONE

### Phase 2 — App i18n with next-intl (Tasks 2.1–2.9)

2.1 Set up next-intl configuration and middleware — DONE

2.2 Establish `/messages/en.json` structure and namespaces — DONE

2.3 Add LanguageSelector and wire locales (client-safe constants) — DONE

2.4 Internationalize Admin Dashboard and Master Data landing — DONE

2.5 Internationalize Providers list and Provider detail pages — DONE

2.6 Internationalize Auth pages (Login, MFA setup/verify) — DONE

2.7 Internationalize Admin Master Data managers (languages, service radius, experience levels, categories, sampradayas, mapping, terms) — DONE

2.8 Internationalize layout footer — DONE

2.9 Build verification and linting pass after extraction — DONE

## Service usage examples (DB i18n)

Below are concise examples showing how to read and write translated fields stored as JSONB alongside legacy columns.

### Reading with fallback (TypeScript + Supabase JS)

```ts
import { createClient } from '@/lib/supabaseServer'

type Locale = 'en' | 'kn'

export async function listCategories(locale: Locale) {
  const supabase = await createClient()
  // Fetch base columns and JSONB translations
  const { data, error } = await supabase
    .from('categories')
    .select('code, name, description, name_translations, description_translations')
    .is('deleted_at', null)
    .order('display_order')
  if (error) throw error

  // Map with locale fallback to legacy columns
  return (data || []).map((c) => ({
    code: c.code,
    name: c.name_translations?.[locale] ?? c.name,
    description: c.description_translations?.[locale] ?? c.description ?? null,
  }))
}
```

### Writing/updating a translation entry (merge-safe)

```ts
import { createClient } from '@/lib/supabaseServer'

type Locale = 'en' | 'kn'

export async function updateCategoryNameTranslation(code: string, locale: Locale, text: string) {
  const supabase = await createClient()

  // 1) Read existing translations
  const { data: existing, error: readErr } = await supabase
    .from('categories')
    .select('name_translations')
    .eq('code', code)
    .single()
  if (readErr) throw readErr

  // 2) Merge in memory
  const updated = { ...(existing?.name_translations ?? {}), [locale]: text }

  // 3) Update JSONB column (non-breaking)
  const { error: updErr } = await supabase
    .from('categories')
    .update({ name_translations: updated })
    .eq('code', code)
  if (updErr) throw updErr
}
```

### SQL example (server-side migration/maintenance)

```sql
-- Set Kannada translation for a category without overwriting others
update categories
set name_translations = jsonb_set(coalesce(name_translations, '{}'::jsonb), '{kn}', to_jsonb('ಪುಜಾರಿ'::text), true)
where code = 'PUROHIT';
```

Guidelines:

- Prefer reading legacy columns as fallback to avoid breaking existing UI.
- Always merge existing JSONB objects when writing to avoid overwriting other locales.
- Keep server API responses locale-aware by mapping translations before returning to clients.

## Backend API locale handling (Milestone 4A)

- Server utility: `apps/web/lib/i18n/locale-server.ts`
  - `getLocaleFromRequest(req)`: resolves locale from `?locale` or `cookie`, defaults to `en`.
  - `sanitizeLocale(value)`: validates against supported locales from i18n config.

- Updated master data endpoints to accept locale and return translated fields with English fallback:
  - `apps/web/app/api/admin/master-data/categories/route.ts`
  - `apps/web/app/api/admin/master-data/sampradayas/route.ts`
  - `apps/web/app/api/admin/master-data/languages/route.ts`
  - `apps/web/app/api/admin/master-data/service-radius/route.ts`
  - `apps/web/app/api/admin/master-data/experience-levels/route.ts`
  - `apps/web/app/api/admin/master-data/terms/route.ts`
  - `apps/web/app/api/admin/categories/route.ts` (admin filter list)

- Mapping pattern used in routes:
  - Read base columns and JSONB translations.
  - Return `translated_*` fields (e.g., `translated_name`, `translated_description`, `translated_content`).
  - Preserve original columns for backward compatibility.

- Next steps:
  - Public providers: `/api/providers/search`, `/api/providers/[id]` to return translated taxonomy fields.
  - Admin providers: `/api/admin/providers`, `/api/admin/providers/[id]` to include translated badges/labels.
  - Services: `apps/web/lib/services/taxonomy.ts` to accept a `locale` and pass through consistently.

## Phase 4B utilities

- Locale skeleton generator
  - Path: `scripts/gen-locale-skeleton.mjs`
  - Usage: `node scripts/gen-locale-skeleton.mjs apps/web/messages/en.json apps/web/messages/kn.json`
  - Behavior: mirrors all keys from source and sets leaf strings to empty values (arrays preserved as empty strings). Use this to bootstrap `kn.json` safely.

- DB Kannada seed script
  - Path: `infra/supabase/seed_kn_master_data.sql`
  - Purpose: Upserts Kannada (`kn`) values into JSONB translation columns for master data tables without overwriting existing locales.
  - Tables covered: `categories`, `sampradayas`, `languages`, `service_radius_options`, `experience_levels`, `terms`.
  - How it works: Uses `jsonb_set(..., '{kn}', to_jsonb(...), true)` with `WHERE (col ->> 'kn') IS NULL` to only set when missing.
  - Run in Supabase SQL editor:
    1. Open your Supabase project's SQL editor.
    2. Paste the contents of `infra/supabase/seed_kn_master_data.sql`.
    3. Execute and verify row counts.
  - Idempotent: Safe to re-run; it won't overwrite existing `kn` entries.

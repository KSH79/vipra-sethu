# Internationalization (i18n) – Phase 1 Overview

This document summarizes the database i18n infrastructure added in Milestone 2 – Phase 1.

- Translation JSONB columns added to master data tables with GIN indexes
- Non-breaking: original `name`, `description`, and `content` columns are retained
- Existing English data migrated into JSONB under `en`
- Profiles table includes `preferred_language` with validation and index
- Helper utilities provided for reading/writing translations in code

## Affected Tables and Columns

- categories: `name_translations`, `description_translations`
- sampradayas: `name_translations`, `description_translations`
- languages: `name_translations`
- service_radius_options: `name_translations`, `description_translations`
- experience_levels: `name_translations`, `description_translations`
- terms: `content_translations`
- profiles: `preferred_language`

Indexes created for every new JSONB column (GIN) and for `profiles.preferred_language`.

## Helper Functions

Location: `apps/web/lib/translations/db-helpers.ts`

- `getTranslation(translations, locale, fallback='en')`
- `buildTranslation(englishText, translations?)`
- `updateTranslation(existing, locale, text)`
- `hasTranslation(translations, locale)`
- `getTranslationCoverage(items, locale, fields)`

Types are available at `apps/web/lib/translations/types.ts`.

## Rollback

A rollback script is available at `infra/supabase/21_i18n_rollback.sql` to drop the added columns and indexes and remove `preferred_language` if necessary.

## Testing

Unit tests for helper functions are under `apps/web/__tests__/translations/db-helpers.spec.ts` (Vitest).

## Next Steps (Phase 2)

- Integrate `next-intl`, add `/messages` structure, middleware, hooks, and a Language Selector component.
- Extract UI strings into `messages/en.json` (no Kannada content yet).

## Milestone 2 — Task Checklist

### Phase 1 — Database i18n Infrastructure (Tasks 1.1–1.7)

1.1 Add JSONB translation columns + GIN indexes to master data tables — DONE

1.2 Backfill existing English content under `en` — DONE

1.3 Rollback script for all changes — DONE

1.4 Helpers and types for translations — DONE

1.5 Update queries/services to include translated fields — DONE

1.6 Apply migration on all dev environments and validate — DONE

1.7 Documentation examples in services and usage patterns — DONE

### Phase 2 — App i18n with next-intl (Tasks 2.1–2.9)

2.1 Set up next-intl configuration and middleware — DONE

2.2 Establish `/messages/en.json` structure and namespaces — DONE

2.3 Add LanguageSelector and wire locales (client-safe constants) — DONE

2.4 Internationalize Admin Dashboard and Master Data landing — DONE

2.5 Internationalize Providers list and Provider detail pages — DONE

2.6 Internationalize Auth pages (Login, MFA setup/verify) — DONE

2.7 Internationalize Admin Master Data managers (languages, service radius, experience levels, categories, sampradayas, mapping, terms) — DONE

2.8 Internationalize layout footer — DONE

2.9 Build verification and linting pass after extraction — DONE

## Service usage examples (DB i18n)

Below are concise examples showing how to read and write translated fields stored as JSONB alongside legacy columns.

### Reading with fallback (TypeScript + Supabase JS)

```ts
import { createClient } from '@/lib/supabaseServer'

type Locale = 'en' | 'kn'

export async function listCategories(locale: Locale) {
  const supabase = await createClient()
  // Fetch base columns and JSONB translations
  const { data, error } = await supabase
    .from('categories')
    .select('code, name, description, name_translations, description_translations')
    .is('deleted_at', null)
    .order('display_order')
  if (error) throw error

  // Map with locale fallback to legacy columns
  return (data || []).map((c) => ({
    code: c.code,
    name: c.name_translations?.[locale] ?? c.name,
    description: c.description_translations?.[locale] ?? c.description ?? null,
  }))
}
```

### Writing/updating a translation entry (merge-safe)

```ts
import { createClient } from '@/lib/supabaseServer'

type Locale = 'en' | 'kn'

export async function updateCategoryNameTranslation(code: string, locale: Locale, text: string) {
  const supabase = await createClient()

  // 1) Read existing translations
  const { data: existing, error: readErr } = await supabase
    .from('categories')
    .select('name_translations')
    .eq('code', code)
    .single()
  if (readErr) throw readErr

  // 2) Merge in memory
  const updated = { ...(existing?.name_translations ?? {}), [locale]: text }

  // 3) Update JSONB column (non-breaking)
  const { error: updErr } = await supabase
    .from('categories')
    .update({ name_translations: updated })
    .eq('code', code)
  if (updErr) throw updErr
}
```

### SQL example (server-side migration/maintenance)

```sql
-- Set Kannada translation for a category without overwriting others
update categories
set name_translations = jsonb_set(coalesce(name_translations, '{}'::jsonb), '{kn}', to_jsonb('ಪುಜಾರಿ'::text), true)
where code = 'PUROHIT';
```

Guidelines:

- Prefer reading legacy columns as fallback to avoid breaking existing UI.
- Always merge existing JSONB objects when writing to avoid overwriting other locales.
- Keep server API responses locale-aware by mapping translations before returning to clients.
